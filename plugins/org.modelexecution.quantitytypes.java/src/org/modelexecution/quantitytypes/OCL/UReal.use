model UReal

-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- This model provides type "UReal" and its operations.
--
-- It sssumes uncertainties follow normal distributions.
-- See the paper "Expressing Measurement Uncertainty 
-- in Software Models" by A. Vallecillo, C. Morcillo, 
-- P. Orue. In Proc. of QUATIC 2016.
--
-- The operations have been specified using SOIL 
-- (Simple OCL-like Imperative Language) which is part of USE
-- http://www.db.informatik.uni-bremen.de/publications/Buettner_2014_SCPSOIL.pdf
--
-- The OCL specifications of the operations using pre- and post-conditions
-- can be found at the end of this file.
--
-- This module assumes operations "sqrt" and "power" on OCL type Real, 
-- currently not supported because they are not included in the OCL standard.
-- They have been included in the extensions to USE using its
-- predefined extensions mechanisms (they need to be placed in the USE 
-- folder "oclExtensions")
-- 
-- AUTHOR:  A. Vallecillo. av@lcc.uma.es
-- VERSION: 1.0
-- DATE: 8 Sep 2016
-- 
-- Thanks to Priscill Orue, Carmen Morcillo and Martin Gogolla for their help,
-- comments and suggestions on previous versions of this OCL/USE specification
--

-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

class UReal
attributes
    x : Real
    u : Real

operations

add(r : UReal) : UReal
    begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x + r.x;
        aux.u := (self.u*self.u + r.u*r.u).sqrt();
        result := aux;
    end   

minus(r : UReal) : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x - r.x;
        aux.u := (self.u*self.u + r.u*r.u).sqrt();
        result := aux;
    end   
   
mult(r : UReal) : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x*r.x;
        aux.u := (r.u*r.u*self.x*self.x + self.u*self.u*r.x*r.x).sqrt();
        result := aux;
     end   
    
divideBy(r : UReal) : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := (self.x/r.x + (self.x*r.u*r.u)/(r.x*r.x*r.x));
        aux.u := ((self.u*self.u/r.x) + 
                 ((r.u*r.u*self.x*self.x)/(r.x*r.x*r.x*r.x))).sqrt();
        result := aux;
    end   

   
abs() : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := (self.x).abs();
        aux.u := self.u;
        result := aux;
    end   
    
neg() : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := -self.x;
        aux.u := self.u;
        result := aux;
    end   

floor() : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x.floor();
        aux.u := self.u;
        result := aux;
    end   
    
round() : UReal
    begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x.round();
        aux.u := self.u;
        result := aux;
    end   
    
inverse() : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := 1.0;
        aux.u := 0.0;
        result := aux.divideBy(self);
    end   
    
power (s : Real) : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x.power(s) + ((s*(s-1))/2)*self.x.power(s-2)*(self.u*self.u);
        aux.u := s*self.u*self.x.power(s-1);
        result := aux;
    end   
    
sqrt() : UReal 
    begin
        declare aux : UReal;
        aux := self.power(0.5);
        result := aux;
    end
   
lessThan(r : UReal) : Boolean
   = (self.x<r.x) and ((self.x + self.u)<(r.x - r.u)) 

lessEq(r : UReal) : Boolean 
   = self.lessThan(r) or self.equals(r)
    
equals(r : UReal) : Boolean 
   = (self.x - self.u).max(r.x - r.u) <= 
         (self.x + self.u).min(r.x + r.u)
    
distinct(r : UReal) : Boolean
    = not self.equals(r) 
    
compareTo(r : UReal) : Integer
    = if self.equals(r) then 0
      else if self.lessThan(r) then -1 
           else 1 
           endif 
      endif
    
max(r : UReal) : UReal
    = if r.lessThan(self) then self else r endif
   
min(r : UReal) : UReal
    = if r.lessThan(self) then r else self endif
  

end

constraints -- preconditions on operations

context UReal::divideBy(r : UReal) : UReal
    pre:  (r.x - r.u).max(0) > (r.x + r.u).min(0) --not r.equals(0,0)

context UReal::sqrt() : UReal
    pre:  (self.x + self.u)>=0.0 

 context UReal::inverse() : UReal
    pre:  (self.x - self.u).max(0) > (self.x + self.u).min(0) -- not self.equals(0.0)

-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- OCL VERSION OF THE OPERATIONS OF TYPE UReal
-- USING PRE AND POST CONDITIONS
-- 
-- context UReal::add(r : UReal) : UReal
-- post: result.x = self.x + r.x and
--       result.u = (self.u*self.u + r.u*r.u).sqrt()
-- 
-- context UReal::minus(r : UReal) : UReal
-- post: result.x = self.x - r.x and
--       result.u = (self.u*self.u - r.u*r.u).sqrt()
-- 
-- context UReal::mult(r : UReal) : UReal
-- post: result.x = (self.x*r.x) and
--       result.u = (r.u*r.u*self.x*self.x + self.u*self.u*r.x*r.x).sqrt()
-- 
--   context UReal::divideBy(r : UReal) : UReal
--   pre:  (r.x - r.u).max(0) > (r.x + r.u).min(0) -- not r.equals(0,0)
--   post: result.x = (self.x/r.x + (self.x*r.u*r.u)/(r.x*r.x*r.x)) and
--         result.u = ((self.u*self.u/r.x) + 
--                     ((r.u*r.u*self.x*self.x)/(r.x*r.x*r.x*r.x))).sqrt()
-- 
-- context UReal::abs() : UReal
--   post: result.x = (self.x).abs() and
--         result.u = self.u
-- 
-- context UReal::neg() : UReal
--   post: result.x = -self.x and 
--         result.u = self.u
-- 
-- context UReal::power(s : Real) : UReal
--   post: result.x = self.x.power(s) + 
--                    ((s*(s-1))/2)*self.x.power(s-2)*(self.u*self.u) and
--         result.u = s*self.u*self.x.power(s-1)
--
-- context UReal::equals(r : UReal) : Boolean 
--   post: result = (self.x - self.u).max(r.x - r.u) <= 
--                  (self.x + self.u).min(r.x + r.u)
--
-- context UReal::distinct(r : UReal) : Boolean 
--   post: result = not self.equals(r)
--
-- context UReal::lessThan(r : UReal) : Boolean 
--   post: result = (self.x<r.x) and ((self.x + self.u)<(r.x - r.u))
--  
-- context UReal::lessEq(r : UReal) : Boolean 
--   post: result = self.lessThan(r) or self.equals(r)
--
-- context UReal::inverse() : UReal
--     pre: (self.x - self.u).max(0) > (self.x + self.u).min(0) --not r.equals(0,0)
--     post: result.x = 1/self.x and result.u = self.u
-- 
-- context UReal::sqrt() : UReal
--     pre: (self.x + self.u)>=0.0  -- self>=0
--     post: result = self.power(0.5)
--     
-- context UReal::max(r :UReal) :UReal
--   post: result = if r.lessThan(self) then self
--                  else r endif
-- 
-- context UReal::min(r :UReal) :UReal
--   post: result = if r.lessThan(self) then r
--                  else self endif
-- 
-- context UReal::floor() :UReal
--   post: result.x = self.x.floor() and
--         result.u = self.u
--
-- context UReal::round() :UReal
--   post: result.x = self.x.round() and
--         result.u = self.u

