model MovingRobot

class Coordinate
attributes
  x : Length
  y : Length
  xy : Tuple(x:Real,y:Real) derived: Tuple{x:x.value.x,y:y.value.x}
  u : Tuple(ux:Real,uy:Real) derived: Tuple{ux:x.value.u,uy:y.value.u}
operations
  coincide(c:Coordinate):Boolean -- self.x.equals(c.x) and self.y.equals(c.y);
  begin
    declare fx:Boolean, fy:Boolean;
    fx:=self.x.equals(c.x);
    fy:=self.y.equals(c.y);
    result :=  fx and fy;
  end
  uCoincide(c:Coordinate):Real -- self.x.uEquals(c.x) * self.y.uEquals(c.y);
  begin
    declare fx:Real, fy:Real;
    fx:=self.x.uEquals(c.x);
    fy:=self.y.uEquals(c.y);
    result :=  fx * fy;
  end
end
  
class Robot
attributes
  position : Coordinate 
  headsTo : Angle
  xyh : Tuple(x:Real,y:Real,h:Real) derived: Tuple{x:position.x.value.x,y:position.y.value.x,h:headsTo.value.x}
  u : Tuple(ux:Real,uy:Real,uh:Real) derived: Tuple{ux:position.x.value.u,uy:position.y.value.u,uh:headsTo.value.u}
operations
   performAllMoves()
   begin
      for m in self.moves do
          m.performMove()
      end
   end
end

class Target
attributes
  position : Coordinate
end

association Mission between 
  Robot [*] role robot
  Target [1] role target
end

class Movement
attributes
   move:Length
   rotate:Angle
operations
   performMove()
   begin
     declare aux:Coordinate, sa:UReal, ca:UReal, dx:Length, dy:Length;
     -- we change the angle first (if we have to), to move in that direction
     if not self.rotate.oclIsUndefined() then 
         self.robot.headsTo:=self.rotate
     end;
     -- and then we move (if we have to)
     if not self.move.oclIsUndefined() then
         sa:=self.robot.headsTo.sin();
         ca:=self.robot.headsTo.cos();
         dx:=self.move.sMult(ca);
         dy:=self.move.sMult(sa);
         aux := new Coordinate;
         aux.x := self.robot.position.x.add(dx);
         aux.y := self.robot.position.y.add(dy);
         self.robot.position:=aux;
     end;
   end
end

association Plan between 
  Robot [1] role robot
  Movement [*] role moves ordered
end

constraints

-- context Robot inv PrecisionUnderControl:
--   self.position.x.value.u < 0.01 and self.position.y.value.u < 0.01

-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- Quantities, Units, UReal modules start here
-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--
-- This model provides types "UReal", "Unit" and "Quantity"
-- and their corresponding operations, as defined first in the paper
-- "Adding Uncertainty and Units to Quantity Types in Software Models" 
-- by T. Mayerhofer, M. Wimmer and A. Vallecillo. In Proc. of SLE 2016,
--
-- It has been updated in version 2.0 to incorporate 
-- a) fuzzy comparison operators that return Real instead of Boolean.
-- b) change of names of comparison operators lessThan (to "lt") and 
--    lessEq (to "le").
-- c) ISO 80000 new units: Bit, Shannon, Erlang, Decibel.
--
-- The operations in this file have been specified using SOIL 
-- (Simple OCL-like Imperative Language) which is part of USE
-- http://www.db.informatik.uni-bremen.de/publications/Buettner_2014_SCPSOIL.pdf
-- The benefits of this approach is that SOIL specification can be executed.
--
-- The OCL specifications of the operations using OCL pre- and post-conditions
-- can be found in the companion file "Quantities.ocl".

-- This module assumes operations "sqrt", "log" and "power" on OCL type Real, 
-- currently not supported because they are not included in the OCL standard.
-- Similarly for the "sum", "minus" (sum and subtraction of arrays)
-- and "mult" (multiplication by a scalar) operations on Sequence(Real).
-- It also uses some normal distribution functions, in particular the 
-- cumulative distribution function (cdf) operation.
-- 
-- These operations have been included in the extensions to USE using its
-- predefined extensions mechanisms (files "Real.xml", "Distributions.xml" 
-- and "Sequence.xml" need to be placed in the USE folder "oclExtensions"). 
-- Warning: in case these files 
-- already exist in the oclExtensions folder, please make sure the contents of 
-- the new ones extend what is currently in the existing ones.
--
-- AUTHORS: A. Vallecillo, Loli Burgueño, Tanja Mayerhofer and Manuel Wimmer. 
-- CONTACT: av@lcc.uma.es
-- VERSION: 2.0
-- DATE: 31 Aug 2017
-- 
-- Thanks to Martin Gogolla for his help, comments and suggestions on 
-- previous versions of this OCL/USE specification.


-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-- model Quantities

class Unit

attributes
  name : String
  symbol : String
  dimensions : Sequence(Real)
  conversionFactor : Sequence(Real)
  offset : Sequence(Real)
  
operations

isCompatibleWith(u :Unit) : Boolean
  = (self.dimensions = u.dimensions)

equals(u :Unit) :Boolean 
  = (self.dimensions = u.dimensions) and
    (self.conversionFactor = u.conversionFactor) and
    (self.offset = u.offset) 

isBaseUnit() :Boolean
  = (self.dimensions->count(1.0)=1) and 
    (self.dimensions->count(0.0)=(self.dimensions->size()-1)) and
    (self.noOffset()) and
    (self.conversionFactor->count(1.0)=self.dimensions->size())

isDimensionless() :Boolean
  = (self.dimensions->count(0.0)=self.dimensions->size())

isUnitless() :Boolean -- Only Radian (12) and Erlang (10)
  = (self.dimensions->subSequence(1,9)->count(0.0)=9) and
    (self.dimensions->subSequence(11,11)->count(0.0)=1)

-- isUnitless() :Boolean -- Only Radian
--   = (self.dimensions->subSequence(1,11)->count(0.0)=11)
  
factor() :Real -- reqired for conversions
   = Sequence{1..12}->
       iterate(i : Integer; acc : Real = 1.0 | acc*(self.conversionFactor->at(i)).power(self.dimensions->at(i)))

isDerivedUnit() :Boolean =
   let DerivedUnitDimensions  : Sequence(Sequence(Real)) = Sequence{	
--   Length, Mass, Time, ElectricCurrent, ThermodynamicTemperature, AmountOfSubstance,LuminousIntensity, Storage, Entropy, Load, Noise, Angle
--   L, M, T, I, O, N, J, S, E, L, D, U
--   Meter, Kilogram, Second, Ampere, Kelvin, Mole, Candela, Bit, Shannon, Erlang, Decibel, Radian
--   m, kg, s, A, K, mol, cd, bit, Sh, E, dB, rad
            Sequence{ 2, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Gy', 		L2T-2	Gray	unit:Gray	Gy
            Sequence{ 2, 0,-3, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Gy/s', 		L2T-3	Gray per second	unit:GrayPerSecond	Gy/s
            Sequence{ 0, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Bq', 		T-1	Becquerel	unit:Becquerel	Bq
            Sequence{-3, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},  -- 'mol/m^3', 		L-3N1	Mole per cubic meter	unit:MolePerCubicMeter	mol/m^3
            Sequence{ 0,-1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},  -- 'mol/kg', 		M-3N1	Mole per kilogram	unit:MolePerKilogram	mol/kg
            Sequence{ 0, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 1},  -- 'rad/s^2', 		U1T-2	Radian per second squared	unit:RadianPerSecondSquared	rad/s^2
            Sequence{ 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'kg*m^2', 		L2M1	Kilogram Meter Squared	unit:KilogramMeterSquared	kg-m^2
            Sequence{ 2, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'J*s', 		L2M1T-1	Joule Second	unit:JouleSecond	J s
            Sequence{ 0, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 1},  -- 'rad/s', 		U1T-1	Radian per second	unit:RadianPerSecond	rad/s
            Sequence{ 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm^2', 		L2	Square meter	unit:SquareMeter	m^2
            Sequence{ 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2},  -- 'm^2*st', 		U1L2	Square meter steradian	unit:SquareMeterSteradian	m^2-sr
            Sequence{ 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},  -- 'm^2*K', 		L2Θ1	Square meter kelvin	unit:SquareMeterKelvin	m^2-K
            Sequence{ 2, 0, 0, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'm^2/K', 		L2Θ-1	Square meter per kelvin	unit:SquareMeterPerKelvin	m^2/K
            Sequence{-2,-1, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'F', 		L-2M-1T4I2	Farad	unit:Farad	F
            Sequence{ 0, 0,-1, 0, 0, 1, 0, 0, 0, 0, 0, 0},  -- 'kat', 		T-1N1	Katal	unit:Katal	kat
            Sequence{ 0, 1,-3, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'W/(m^2*K)', 	M1T-3Θ-1	M1T-3Θ-1	Watt per square meter kelvin	unit:WattPerSquareMeterKelvin	W/(m^2-K)
            Sequence{-3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'kg/m^3', L-3M1		L-3M1	Kilogram per cubic meter	unit:KilogramPerCubicMeter	kg/m^3
            Sequence{ 2, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Sv', L2T-2		L2T-2	Sievert	unit:Sievert	Sv
            Sequence{-1, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Pa*s', L-1M1T-1		L-1M1T-1	Pascal second	unit:PascalSecond	Pa-s
            Sequence{ 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'C', T1I1		T1I1	Coulomb	unit:Coulomb	C
            Sequence{-1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'C/m', L-1T1I1		L-1T1I1	Coulomb per meter	unit:CoulombPerMeter	C/m
            Sequence{-3, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'C/m^3', L-3T1I1		L-3T1I1	Coulomb per cubic meter	unit:CoulombPerCubicMeter	C/m^3
            Sequence{ 0, 0, 1, 1, 0,-1, 0, 0, 0, 0, 0, 0},  -- 'C/mol', 		T1I1N-1	Coulomb per mole	unit:CoulombPerMole	C/mol
            Sequence{-2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'A/m^2', 		L-2I1	Ampere per square meter	unit:AmperePerSquareMeter	A/m^2
            Sequence{ 0, 0, 0,-1, 0, 0, 0, 0, 0, 0, 0,-1},  -- 'A/rad', 		U-1I1	Ampere per radian	unit:AmperePerRadian	A/rad
            Sequence{ 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'C*m', 		L1T1I1	Coulomb meter	unit:CoulombMeter	C-m
            Sequence{ 1, 1,-3,-1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'V/m', 		L1M1T-3I-1	Volt per Meter	unit:VoltPerMeter	V/m
            Sequence{-2, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'C/m^2', 		L-2T1I1	Coulomb per Square Meter	unit:CoulombPerSquareMeter	C/m^2
            Sequence{-2,-1, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'S', 		L-2M-1T3I2	Siemens	unit:Siemens	S
            Sequence{ 2, 1,-3,-1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'V', 		L2M1T-3I-1	Volt	unit:Volt	V
            Sequence{-1, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'J/m^3', 		L-1M1T-2	Joule per cubic meter	unit:JoulePerCubicMeter	J/m^3
            Sequence{ 2, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'J', 		L2M1T-2	Joule	unit:Joule	J
            Sequence{ 0, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'J/m^2', 		M1T-2	Joule per square meter	unit:JoulePerSquareMeter	J/m^2
            Sequence{ 0,-1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'C/kg', 		M-1T1I1	Coulomb per kilogram	unit:CoulombPerKilogram	C/kg
            Sequence{ 1, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'N', 		L1M1T-2	Newton	unit:Newton	N
            Sequence{ 1, 1,-3,-1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'N/C', 		L1M1T-3I-1	Newton per coulomb	unit:NewtonPerCoulomb	N/C
            Sequence{ 0, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'N/m', 		M1T-2	Newton per meter	unit:NewtonPerMeter	N/m
            Sequence{ 0, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Hz', 		T-1	Hertz	unit:Hertz	Hz
            Sequence{ 3,-1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm^3/(kg*s^2)', 		L3M-1T-2	Cubic meter per kilogram second squared	unit:CubicMeterPerKilogramSecondSquared	m^3/(kg-s^2)
            Sequence{ 2, 1,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'J/K', 		L2M1T-2Θ-1	Joule per kelvin	unit:JoulePerKelvin	J/K
            Sequence{-2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1},  -- 'Lx', 		U1L-2J1	Lux	unit:Lux	lx
            Sequence{ 2, 1,-2,-2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'H', 		L2M1T-2I-2	Henry	unit:Henry	H
            Sequence{ 0, 0, 0, 0, 0,-1, 0, 0, 0, 0, 0, 0},  -- '1/mol', 		N-1	Per mole	unit:PerMole	mol^(-1)
            Sequence{ 3, 1,-4,-2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm/F', 		L3M1T-4I-2	Meter per farad	unit:MeterPerFarad	m/F
            Sequence{ 2, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm^2/s', 		L2T-1	Square meter per second	unit:SquareMeterPerSecond	m^2/sec
            Sequence{ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm*kg', 		L1M1	Meter kilogram	unit:MeterKilogram	m-kg
            Sequence{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},  -- 'm*K', 		L1Θ1	Meter kelvin	unit:MeterKelvin	m-K
            Sequence{ 1, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm/s^2', 		L1T-2	Meter per second squared	unit:MeterPerSecondSquared	m/s^2
            Sequence{ 1, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'kg*m/s', 		L1M1T-1	Kilogram Meter Per Second	unit:KilogramMeterPerSecond	kg-m/s
            Sequence{ 1, 0, 0, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'm/K', 		L1Θ-1	Meter per kelvin	unit:MeterPerKelvin	m/K
            Sequence{ 1, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm/s', 		L1T-1	Meter per second	unit:MeterPerSecond	m/s
            Sequence{-2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},  -- 'cd/m^2', 		L-2J1	Candela per square meter	unit:CandelaPerSquareMeter	cd/m^2
            Sequence{ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1},  -- 'lm', 		U1J1	Lumen	unit:Lumen	lm
            Sequence{ 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'J/T', 		L2I1	Joule per Tesla	unit:JoulePerTesla	J/T
            Sequence{-1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'AT/m', 		L-1I1	Ampere Turn per Meter	unit:AmpereTurnPerMeter	At/m
            Sequence{ 2, 1,-2,-1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Wb', 		L2M1T-2I-1	Weber	unit:Weber	Wb
            Sequence{ 0, 1,-2,-1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'T', 		M1T-2I-1	Tesla	unit:Tesla	T
            Sequence{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1},  -- 'AT', 		U1I1	Ampere Turn	unit:AmpereTurn	At
            Sequence{ 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},  -- 'kg*K', 		M1Θ1	Kilogram kelvin	unit:KilogramKelvin	kg-K
            Sequence{ 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'kg/s', 		M1T-1	Kilogram per second	unit:KilogramPerSecond	kg/s
            Sequence{-2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'kg/m^2', 		L-2M1	Kilogram per square meter	unit:KilogramPerSquareMeter	kg/m^2
            Sequence{-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'kg/m', 		L-1M1	Kilogram per meter	unit:KilogramPerMeter	kg/m
            Sequence{ 2, 1,-2, 0, 0,-1, 0, 0, 0, 0, 0, 0},  -- 'J/mol', 		L2M1T-2N-1	Joule per mole	unit:JoulePerMole	J/mol
            Sequence{ 2, 1,-2, 0,-1,-1, 0, 0, 0, 0, 0, 0},  -- 'J/(mol*K)', 		L2M1T-2Θ-1N-1	Joule per mole kelvin	unit:JoulePerMoleKelvin	J/(mol-K)
            Sequence{ 1, 1,-2,-2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'H/m', 		L1M1T-2I-2	Henry per meter	unit:HenryPerMeter	H/m
            Sequence{-3,-1, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'F/m', 		L-3M-1T4I2	Farad per meter	unit:FaradPerMeter	F/m
            Sequence{ 2, 1,-3, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'W', 		L2M1T-3	Watt	unit:Watt	W
            Sequence{ 2, 1,-3, 0, 0, 0, 0, 0, 0, 0, 0,-2},  -- 'W/sr', 		U-1L2M1T-3	Watt per steradian	unit:WattPerSteradian	W/sr
            Sequence{ 0, 1,-3, 0, 0, 0, 0, 0, 0, 0, 0,-2},  -- 'W/(m^2sr)', 		U-1M1T-3	Watt per square meter steradian	unit:WattPerSquareMeterSteradian	W/(m^2-sr)
            Sequence{ 0, 1,-3, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'W/m^2', 		M1T-3	Watt per square meter	unit:WattPerSquareMeter	W/m^2
            Sequence{-1, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Pa', 		L-1M1T-2	Pascal	unit:Pascal	Pa
            Sequence{ 2, 1,-3,-2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Ohm', 		L2M1T-3I-2	Ohm	unit:Ohm	Ohm
            Sequence{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2},  -- 'sr', 		U1	Steradian	unit:Steradian	sr
            Sequence{ 2, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'J/kg', 		L2T-2	Joule per kilogram	unit:JoulePerKilogram	J/kg
            Sequence{ 2, 0,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'J/(kg*K)', 		L2T-2Θ-1	Joule per kilogram kelvin	unit:JoulePerKilogramKelvin	J/(kg-K)
            Sequence{ 3,-1, 0, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'J/(kg*K*Pa)', 		L3M-1Θ-1	Joule per kilogram kelvin per pascal	unit:JoulePerKilogramKelvinPerPascal	J/(km-K-Pa)
            Sequence{-1, 0,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'J/(kg*K*m^3)', 		L-1T-2Θ-1	Joule per kilogram kelvin per cubic meter	unit:JoulePerKilogramKelvinPerCubicMeter	J/(kg-K-m^3)
            Sequence{ 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0},  -- 'mol*K', 		Θ1N1	Mole kelvin	unit:MoleKelvin	mol-K
            Sequence{ 1, 1,-3, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'W/(m*K)', 		L1M1T-3Θ-1	Watt per meter kelvin	unit:WattPerMeterKelvin	W/(m*K)
            Sequence{ 0,-1, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0},  -- 'm^2/W', 		M-1T3Θ1	Square meter Kelvin per watt	unit:SquareMeterKelvinPerWatt	(K^2)m/W
            Sequence{-2,-1, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0},  -- 'K/W', 		L-2M-1T3Θ1	Kelvin per watt	unit:KelvinPerWatt	K/W
            Sequence{-1,-1, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0},  -- 'm*K/W', 		L-1M-1T3Θ1	Meter Kelvin per watt	unit:MeterKelvinPerWatt	K-m/W
            Sequence{ 1, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'N/kg', 		L1T-2	Newton per kilogram	unit:NewtonPerKilogram	N/kg
            Sequence{ 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 's^2', 		T2	Second time squared	unit:SecondTimeSquared	s^2
            Sequence{ 2, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'N*m', 		L2M1T-2	Newton meter	unit:NewtonMeter	N-m
            Sequence{ 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm^3', 		L3	Cubic Meter	unit:CubicMeter	m^3
            Sequence{ 3,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm^3/K', 		L3Θ-1	Cubic meter per kelvin	unit:CubicMeterPerKelvin	m^3/K
            Sequence{ 3, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm^3/s', 		L3T-1	Cubic meter per second	unit:CubicMeterPerSecond	m^3/s
            Sequence{ 1, 1,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0}, -- 'J/(m^3*K)'		L-1M1T-2Θ-1	Joule per cubic meter kelvin	unit:JoulePerCubicMeterKelvin	J/(m^3 K)
            Sequence{ 0, 0,-1, 0, 0, 0, 0, 1, 0, 0, 0, 0} -- 'bit/s'		S1T-1 bit per second
            } in
        DerivedUnitDimensions->includes(self.dimensions) and self.noOffset() and self.conversionFactor->count(1.0)=12

defaultName():String = 
   let BaseUnitNames : Sequence(String) = Sequence{ 'Meter', 'Kilogram', 'Second', 'Ampere', 'Kelvin', 'Mole', 'Candela', 
                                                    'Bit', 'Shannon', 'Erlang', 'Decibel', 'Radian'} in
   let DerivedUnitDimensions  : Sequence(Sequence(Real)) = Sequence{	
--   Length, Mass, Time, ElectricCurrent, ThermodynamicTemperature, AmountOfSubstance,LuminousIntensity, Storage, Entropy, Load, Noise, Angle
--   L, M, T, I, O, N, J, S, E, L, D, U
--   Meter, Kilogram, Second, Ampere, Kelvin, Mole, Candela, Bit, Shannon, Erlang, Decibel, Radian
--   m, kg, s, A, K, mol, cd, bit, Sh, E, dB, rad
            Sequence{ 2, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Gy', 		L2T-2	Gray	unit:Gray	Gy
            Sequence{ 2, 0,-3, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Gy/s', 		L2T-3	Gray per second	unit:GrayPerSecond	Gy/s
            Sequence{ 0, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Bq', 		T-1	Becquerel	unit:Becquerel	Bq
            Sequence{-3, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},  -- 'mol/m^3', 		L-3N1	Mole per cubic meter	unit:MolePerCubicMeter	mol/m^3
            Sequence{ 0,-1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},  -- 'mol/kg', 		M-3N1	Mole per kilogram	unit:MolePerKilogram	mol/kg
            Sequence{ 0, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 1},  -- 'rad/s^2', 		U1T-2	Radian per second squared	unit:RadianPerSecondSquared	rad/s^2
            Sequence{ 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'kg*m^2', 		L2M1	Kilogram Meter Squared	unit:KilogramMeterSquared	kg-m^2
            Sequence{ 2, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'J*s', 		L2M1T-1	Joule Second	unit:JouleSecond	J s
            Sequence{ 0, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 1},  -- 'rad/s', 		U1T-1	Radian per second	unit:RadianPerSecond	rad/s
            Sequence{ 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm^2', 		L2	Square meter	unit:SquareMeter	m^2
            Sequence{ 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2},  -- 'm^2*st', 		U1L2	Square meter steradian	unit:SquareMeterSteradian	m^2-sr
            Sequence{ 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},  -- 'm^2*K', 		L2Θ1	Square meter kelvin	unit:SquareMeterKelvin	m^2-K
            Sequence{ 2, 0, 0, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'm^2/K', 		L2Θ-1	Square meter per kelvin	unit:SquareMeterPerKelvin	m^2/K
            Sequence{-2,-1, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'F', 		L-2M-1T4I2	Farad	unit:Farad	F
            Sequence{ 0, 0,-1, 0, 0, 1, 0, 0, 0, 0, 0, 0},  -- 'kat', 		T-1N1	Katal	unit:Katal	kat
            Sequence{ 0, 1,-3, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'W/(m^2*K)', 	M1T-3Θ-1	M1T-3Θ-1	Watt per square meter kelvin	unit:WattPerSquareMeterKelvin	W/(m^2-K)
            Sequence{-3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'kg/m^3', L-3M1		L-3M1	Kilogram per cubic meter	unit:KilogramPerCubicMeter	kg/m^3
            Sequence{ 2, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Sv', L2T-2		L2T-2	Sievert	unit:Sievert	Sv
            Sequence{-1, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Pa*s', L-1M1T-1		L-1M1T-1	Pascal second	unit:PascalSecond	Pa-s
            Sequence{ 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'C', T1I1		T1I1	Coulomb	unit:Coulomb	C
            Sequence{-1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'C/m', L-1T1I1		L-1T1I1	Coulomb per meter	unit:CoulombPerMeter	C/m
            Sequence{-3, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'C/m^3', L-3T1I1		L-3T1I1	Coulomb per cubic meter	unit:CoulombPerCubicMeter	C/m^3
            Sequence{ 0, 0, 1, 1, 0,-1, 0, 0, 0, 0, 0, 0},  -- 'C/mol', 		T1I1N-1	Coulomb per mole	unit:CoulombPerMole	C/mol
            Sequence{-2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'A/m^2', 		L-2I1	Ampere per square meter	unit:AmperePerSquareMeter	A/m^2
            Sequence{ 0, 0, 0,-1, 0, 0, 0, 0, 0, 0, 0,-1},  -- 'A/rad', 		U-1I1	Ampere per radian	unit:AmperePerRadian	A/rad
            Sequence{ 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'C*m', 		L1T1I1	Coulomb meter	unit:CoulombMeter	C-m
            Sequence{ 1, 1,-3,-1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'V/m', 		L1M1T-3I-1	Volt per Meter	unit:VoltPerMeter	V/m
            Sequence{-2, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'C/m^2', 		L-2T1I1	Coulomb per Square Meter	unit:CoulombPerSquareMeter	C/m^2
            Sequence{-2,-1, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'S', 		L-2M-1T3I2	Siemens	unit:Siemens	S
            Sequence{ 2, 1,-3,-1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'V', 		L2M1T-3I-1	Volt	unit:Volt	V
            Sequence{-1, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'J/m^3', 		L-1M1T-2	Joule per cubic meter	unit:JoulePerCubicMeter	J/m^3
            Sequence{ 2, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'J', 		L2M1T-2	Joule	unit:Joule	J
            Sequence{ 0, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'J/m^2', 		M1T-2	Joule per square meter	unit:JoulePerSquareMeter	J/m^2
            Sequence{ 0,-1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'C/kg', 		M-1T1I1	Coulomb per kilogram	unit:CoulombPerKilogram	C/kg
            Sequence{ 1, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'N', 		L1M1T-2	Newton	unit:Newton	N
            Sequence{ 1, 1,-3,-1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'N/C', 		L1M1T-3I-1	Newton per coulomb	unit:NewtonPerCoulomb	N/C
            Sequence{ 0, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'N/m', 		M1T-2	Newton per meter	unit:NewtonPerMeter	N/m
            Sequence{ 0, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Hz', 		T-1	Hertz	unit:Hertz	Hz
            Sequence{ 3,-1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm^3/(kg*s^2)', 		L3M-1T-2	Cubic meter per kilogram second squared	unit:CubicMeterPerKilogramSecondSquared	m^3/(kg-s^2)
            Sequence{ 2, 1,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'J/K', 		L2M1T-2Θ-1	Joule per kelvin	unit:JoulePerKelvin	J/K
            Sequence{-2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1},  -- 'Lx', 		U1L-2J1	Lux	unit:Lux	lx
            Sequence{ 2, 1,-2,-2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'H', 		L2M1T-2I-2	Henry	unit:Henry	H
            Sequence{ 0, 0, 0, 0, 0,-1, 0, 0, 0, 0, 0, 0},  -- '1/mol', 		N-1	Per mole	unit:PerMole	mol^(-1)
            Sequence{ 3, 1,-4,-2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm/F', 		L3M1T-4I-2	Meter per farad	unit:MeterPerFarad	m/F
            Sequence{ 2, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm^2/s', 		L2T-1	Square meter per second	unit:SquareMeterPerSecond	m^2/sec
            Sequence{ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm*kg', 		L1M1	Meter kilogram	unit:MeterKilogram	m-kg
            Sequence{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},  -- 'm*K', 		L1Θ1	Meter kelvin	unit:MeterKelvin	m-K
            Sequence{ 1, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm/s^2', 		L1T-2	Meter per second squared	unit:MeterPerSecondSquared	m/s^2
            Sequence{ 1, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'kg*m/s', 		L1M1T-1	Kilogram Meter Per Second	unit:KilogramMeterPerSecond	kg-m/s
            Sequence{ 1, 0, 0, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'm/K', 		L1Θ-1	Meter per kelvin	unit:MeterPerKelvin	m/K
            Sequence{ 1, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm/s', 		L1T-1	Meter per second	unit:MeterPerSecond	m/s
            Sequence{-2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},  -- 'cd/m^2', 		L-2J1	Candela per square meter	unit:CandelaPerSquareMeter	cd/m^2
            Sequence{ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1},  -- 'lm', 		U1J1	Lumen	unit:Lumen	lm
            Sequence{ 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'J/T', 		L2I1	Joule per Tesla	unit:JoulePerTesla	J/T
            Sequence{-1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'AT/m', 		L-1I1	Ampere Turn per Meter	unit:AmpereTurnPerMeter	At/m
            Sequence{ 2, 1,-2,-1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Wb', 		L2M1T-2I-1	Weber	unit:Weber	Wb
            Sequence{ 0, 1,-2,-1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'T', 		M1T-2I-1	Tesla	unit:Tesla	T
            Sequence{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1},  -- 'AT', 		U1I1	Ampere Turn	unit:AmpereTurn	At
            Sequence{ 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},  -- 'kg*K', 		M1Θ1	Kilogram kelvin	unit:KilogramKelvin	kg-K
            Sequence{ 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'kg/s', 		M1T-1	Kilogram per second	unit:KilogramPerSecond	kg/s
            Sequence{-2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'kg/m^2', 		L-2M1	Kilogram per square meter	unit:KilogramPerSquareMeter	kg/m^2
            Sequence{-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'kg/m', 		L-1M1	Kilogram per meter	unit:KilogramPerMeter	kg/m
            Sequence{ 2, 1,-2, 0, 0,-1, 0, 0, 0, 0, 0, 0},  -- 'J/mol', 		L2M1T-2N-1	Joule per mole	unit:JoulePerMole	J/mol
            Sequence{ 2, 1,-2, 0,-1,-1, 0, 0, 0, 0, 0, 0},  -- 'J/(mol*K)', 		L2M1T-2Θ-1N-1	Joule per mole kelvin	unit:JoulePerMoleKelvin	J/(mol-K)
            Sequence{ 1, 1,-2,-2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'H/m', 		L1M1T-2I-2	Henry per meter	unit:HenryPerMeter	H/m
            Sequence{-3,-1, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'F/m', 		L-3M-1T4I2	Farad per meter	unit:FaradPerMeter	F/m
            Sequence{ 2, 1,-3, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'W', 		L2M1T-3	Watt	unit:Watt	W
            Sequence{ 2, 1,-3, 0, 0, 0, 0, 0, 0, 0, 0,-2},  -- 'W/sr', 		U-1L2M1T-3	Watt per steradian	unit:WattPerSteradian	W/sr
            Sequence{ 0, 1,-3, 0, 0, 0, 0, 0, 0, 0, 0,-2},  -- 'W/(m^2sr)', 		U-1M1T-3	Watt per square meter steradian	unit:WattPerSquareMeterSteradian	W/(m^2-sr)
            Sequence{ 0, 1,-3, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'W/m^2', 		M1T-3	Watt per square meter	unit:WattPerSquareMeter	W/m^2
            Sequence{-1, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Pa', 		L-1M1T-2	Pascal	unit:Pascal	Pa
            Sequence{ 2, 1,-3,-2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Ohm', 		L2M1T-3I-2	Ohm	unit:Ohm	Ohm
            Sequence{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2},  -- 'sr', 		U1	Steradian	unit:Steradian	sr
            Sequence{ 2, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'J/kg', 		L2T-2	Joule per kilogram	unit:JoulePerKilogram	J/kg
            Sequence{ 2, 0,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'J/(kg*K)', 		L2T-2Θ-1	Joule per kilogram kelvin	unit:JoulePerKilogramKelvin	J/(kg-K)
            Sequence{ 3,-1, 0, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'J/(kg*K*Pa)', 		L3M-1Θ-1	Joule per kilogram kelvin per pascal	unit:JoulePerKilogramKelvinPerPascal	J/(km-K-Pa)
            Sequence{-1, 0,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'J/(kg*K*m^3)', 		L-1T-2Θ-1	Joule per kilogram kelvin per cubic meter	unit:JoulePerKilogramKelvinPerCubicMeter	J/(kg-K-m^3)
            Sequence{ 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0},  -- 'mol*K', 		Θ1N1	Mole kelvin	unit:MoleKelvin	mol-K
            Sequence{ 1, 1,-3, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'W/(m*K)', 		L1M1T-3Θ-1	Watt per meter kelvin	unit:WattPerMeterKelvin	W/(m*K)
            Sequence{ 0,-1, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0},  -- 'm^2/W', 		M-1T3Θ1	Square meter Kelvin per watt	unit:SquareMeterKelvinPerWatt	(K^2)m/W
            Sequence{-2,-1, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0},  -- 'K/W', 		L-2M-1T3Θ1	Kelvin per watt	unit:KelvinPerWatt	K/W
            Sequence{-1,-1, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0},  -- 'm*K/W', 		L-1M-1T3Θ1	Meter Kelvin per watt	unit:MeterKelvinPerWatt	K-m/W
            Sequence{ 1, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'N/kg', 		L1T-2	Newton per kilogram	unit:NewtonPerKilogram	N/kg
            Sequence{ 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 's^2', 		T2	Second time squared	unit:SecondTimeSquared	s^2
            Sequence{ 2, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'N*m', 		L2M1T-2	Newton meter	unit:NewtonMeter	N-m
            Sequence{ 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm^3', 		L3	Cubic Meter	unit:CubicMeter	m^3
            Sequence{ 3,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm^3/K', 		L3Θ-1	Cubic meter per kelvin	unit:CubicMeterPerKelvin	m^3/K
            Sequence{ 3, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm^3/s', 		L3T-1	Cubic meter per second	unit:CubicMeterPerSecond	m^3/s
            Sequence{ 1, 1,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0}, -- 'J/(m^3*K)'		L-1M1T-2Θ-1	Joule per cubic meter kelvin	unit:JoulePerCubicMeterKelvin	J/(m^3 K)
            Sequence{ 0, 0,-1, 0, 0, 0, 0, 1, 0, 0, 0, 0} -- 'bit/s'		S1T-1 bit per second
            } in
 let DerivedUnitNames  : Sequence(String) =Sequence{	
			'Gray',
			'GrayPerSecond',
			'Becquerel',
			'MolePerCubicMeter',
			'MolePerKilogram',
			'RadianPerSecondSquared',
			'KilogramMeterSquared',
			'JouleSecond',
			'RadianPerSecond',
			'SquareMeter',
			'SquareMeterSteradian',
			'SquareMeterKelvin',
			'SquareMeterPerKelvin',
			'Farad',
			'Katal',
			'WattPerSquareMeterKelvin',
			'KilogramPerCubicMeter',
			'Sievert',
			'PascalSecond',
			'Coulomb',
			'CoulombPerMeter',
			'CoulombPerCubicMeter',
			'CoulombPerMole',
			'AmperePerSquareMeter',
			'AmperePerRadian',
			'CoulombMeter',
			'VoltPerMeter',
			'CoulombPerSquareMeter',
			'Siemens',
			'Volt',
			'JoulePerCubicMeter',
			'Joule',
			'JoulePerSquareMeter',
			'CoulombPerKilogram',
			'Newton',
			'NewtonPerCoulomb',
			'NewtonPerMeter',
			'Hertz',
			'CubicMeterPerKilogramSecondSquared',
			'JoulePerKelvin',
			'Lux',
			'Henry',
			'PerMole',
			'MeterPerFarad',
			'SquareMeterPerSecond',
			'MeterKilogram',
			'MeterKelvin',
			'MeterPerSecondSquared',
			'KilogramMeterPerSecond',
			'MeterPerKelvin',
			'MeterPerSecond',
			'CandelaPerSquareMeter',
			'Lumen',
			'JoulePerTesla',
			'AmpereTurnPerMeter',
			'Weber',
			'Tesla',
			'AmpereTurn',
			'KilogramKelvin',
			'KilogramPerSecond',
			'KilogramPerSquareMeter',
			'KilogramPerMeter',
			'JoulePerMole',
			'JoulePerMoleKelvin',
			'HenryPerMeter',
			'FaradPerMeter',
			'Watt',
			'WattPerSteradian',
			'WattPerSquareMeterSteradian',
			'WattPerSquareMeter',
			'Pascal',
			'Ohm',
			'Steradian',
			'JoulePerKilogram',
			'JoulePerKilogramKelvin',
			'JoulePerKilogramKelvinPerPascal',
			'JoulePerKilogramKelvinPerCubicMeter',
			'MoleKelvin',
			'WattPerMeterKelvin',
			'SquareMeterKelvinPerWatt',
			'KelvinPerWatt',
			'MeterKelvinPerWatt',
			'NewtonPerKilogram',
			'SecondTimeSquared',
			'Torque',
			'CubicMeter',
			'CubicMeterPerKelvin',
			'CubicMeterPerSecond',
			'JoulePerCubicMeterKelvin',
            'BitPerSecond' } in
if not self.name.oclIsUndefined() or self.isDimensionless() then
    self.name
else if self.isBaseUnit() then 
        BaseUnitNames->at(self.dimensions->indexOf(1.0))
else if self.isDerivedUnit() then
            DerivedUnitNames->at(DerivedUnitDimensions->indexOf(self.dimensions))
else
            Sequence{1..12}->iterate(i : Integer; acc : String = '' | if self.dimensions->at(i)<>0.0 then 
                acc.concat(BaseUnitNames->at(i)).concat('^').concat(self.dimensions->at(i).toString()) else acc endif)
endif endif endif

defaultSymbol():String = 
let BaseUnitSymbols : Sequence(String) = Sequence{'m', 'kg', 's', 'A', 'K', 'mol', 'cd', 'bit', 'Sh', 'E', 'dB', 'rad'} in
   let DerivedUnitDimensions  : Sequence(Sequence(Real)) = Sequence{	
--   Length, Mass, Time, ElectricCurrent, ThermodynamicTemperature, AmountOfSubstance,LuminousIntensity, Storage, Entropy, Load, Noise, Angle
--   L, M, T, I, O, N, J, S, E, L, D, U
--   Meter, Kilogram, Second, Ampere, Kelvin, Mole, Candela, Bit, Shannon, Erlang, Decibel, Radian
--   m, kg, s, A, K, mol, cd, bit, Sh, E, dB, rad
            Sequence{ 2, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Gy', 		L2T-2	Gray	unit:Gray	Gy
            Sequence{ 2, 0,-3, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Gy/s', 		L2T-3	Gray per second	unit:GrayPerSecond	Gy/s
            Sequence{ 0, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Bq', 		T-1	Becquerel	unit:Becquerel	Bq
            Sequence{-3, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},  -- 'mol/m^3', 		L-3N1	Mole per cubic meter	unit:MolePerCubicMeter	mol/m^3
            Sequence{ 0,-1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},  -- 'mol/kg', 		M-3N1	Mole per kilogram	unit:MolePerKilogram	mol/kg
            Sequence{ 0, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 1},  -- 'rad/s^2', 		U1T-2	Radian per second squared	unit:RadianPerSecondSquared	rad/s^2
            Sequence{ 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'kg*m^2', 		L2M1	Kilogram Meter Squared	unit:KilogramMeterSquared	kg-m^2
            Sequence{ 2, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'J*s', 		L2M1T-1	Joule Second	unit:JouleSecond	J s
            Sequence{ 0, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 1},  -- 'rad/s', 		U1T-1	Radian per second	unit:RadianPerSecond	rad/s
            Sequence{ 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm^2', 		L2	Square meter	unit:SquareMeter	m^2
            Sequence{ 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2},  -- 'm^2*st', 		U1L2	Square meter steradian	unit:SquareMeterSteradian	m^2-sr
            Sequence{ 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},  -- 'm^2*K', 		L2Θ1	Square meter kelvin	unit:SquareMeterKelvin	m^2-K
            Sequence{ 2, 0, 0, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'm^2/K', 		L2Θ-1	Square meter per kelvin	unit:SquareMeterPerKelvin	m^2/K
            Sequence{-2,-1, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'F', 		L-2M-1T4I2	Farad	unit:Farad	F
            Sequence{ 0, 0,-1, 0, 0, 1, 0, 0, 0, 0, 0, 0},  -- 'kat', 		T-1N1	Katal	unit:Katal	kat
            Sequence{ 0, 1,-3, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'W/(m^2*K)', 	M1T-3Θ-1	M1T-3Θ-1	Watt per square meter kelvin	unit:WattPerSquareMeterKelvin	W/(m^2-K)
            Sequence{-3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'kg/m^3', L-3M1		L-3M1	Kilogram per cubic meter	unit:KilogramPerCubicMeter	kg/m^3
            Sequence{ 2, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Sv', L2T-2		L2T-2	Sievert	unit:Sievert	Sv
            Sequence{-1, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Pa*s', L-1M1T-1		L-1M1T-1	Pascal second	unit:PascalSecond	Pa-s
            Sequence{ 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'C', T1I1		T1I1	Coulomb	unit:Coulomb	C
            Sequence{-1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'C/m', L-1T1I1		L-1T1I1	Coulomb per meter	unit:CoulombPerMeter	C/m
            Sequence{-3, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'C/m^3', L-3T1I1		L-3T1I1	Coulomb per cubic meter	unit:CoulombPerCubicMeter	C/m^3
            Sequence{ 0, 0, 1, 1, 0,-1, 0, 0, 0, 0, 0, 0},  -- 'C/mol', 		T1I1N-1	Coulomb per mole	unit:CoulombPerMole	C/mol
            Sequence{-2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'A/m^2', 		L-2I1	Ampere per square meter	unit:AmperePerSquareMeter	A/m^2
            Sequence{ 0, 0, 0,-1, 0, 0, 0, 0, 0, 0, 0,-1},  -- 'A/rad', 		U-1I1	Ampere per radian	unit:AmperePerRadian	A/rad
            Sequence{ 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'C*m', 		L1T1I1	Coulomb meter	unit:CoulombMeter	C-m
            Sequence{ 1, 1,-3,-1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'V/m', 		L1M1T-3I-1	Volt per Meter	unit:VoltPerMeter	V/m
            Sequence{-2, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'C/m^2', 		L-2T1I1	Coulomb per Square Meter	unit:CoulombPerSquareMeter	C/m^2
            Sequence{-2,-1, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'S', 		L-2M-1T3I2	Siemens	unit:Siemens	S
            Sequence{ 2, 1,-3,-1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'V', 		L2M1T-3I-1	Volt	unit:Volt	V
            Sequence{-1, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'J/m^3', 		L-1M1T-2	Joule per cubic meter	unit:JoulePerCubicMeter	J/m^3
            Sequence{ 2, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'J', 		L2M1T-2	Joule	unit:Joule	J
            Sequence{ 0, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'J/m^2', 		M1T-2	Joule per square meter	unit:JoulePerSquareMeter	J/m^2
            Sequence{ 0,-1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'C/kg', 		M-1T1I1	Coulomb per kilogram	unit:CoulombPerKilogram	C/kg
            Sequence{ 1, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'N', 		L1M1T-2	Newton	unit:Newton	N
            Sequence{ 1, 1,-3,-1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'N/C', 		L1M1T-3I-1	Newton per coulomb	unit:NewtonPerCoulomb	N/C
            Sequence{ 0, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'N/m', 		M1T-2	Newton per meter	unit:NewtonPerMeter	N/m
            Sequence{ 0, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Hz', 		T-1	Hertz	unit:Hertz	Hz
            Sequence{ 3,-1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm^3/(kg*s^2)', 		L3M-1T-2	Cubic meter per kilogram second squared	unit:CubicMeterPerKilogramSecondSquared	m^3/(kg-s^2)
            Sequence{ 2, 1,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'J/K', 		L2M1T-2Θ-1	Joule per kelvin	unit:JoulePerKelvin	J/K
            Sequence{-2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1},  -- 'Lx', 		U1L-2J1	Lux	unit:Lux	lx
            Sequence{ 2, 1,-2,-2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'H', 		L2M1T-2I-2	Henry	unit:Henry	H
            Sequence{ 0, 0, 0, 0, 0,-1, 0, 0, 0, 0, 0, 0},  -- '1/mol', 		N-1	Per mole	unit:PerMole	mol^(-1)
            Sequence{ 3, 1,-4,-2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm/F', 		L3M1T-4I-2	Meter per farad	unit:MeterPerFarad	m/F
            Sequence{ 2, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm^2/s', 		L2T-1	Square meter per second	unit:SquareMeterPerSecond	m^2/sec
            Sequence{ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm*kg', 		L1M1	Meter kilogram	unit:MeterKilogram	m-kg
            Sequence{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},  -- 'm*K', 		L1Θ1	Meter kelvin	unit:MeterKelvin	m-K
            Sequence{ 1, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm/s^2', 		L1T-2	Meter per second squared	unit:MeterPerSecondSquared	m/s^2
            Sequence{ 1, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'kg*m/s', 		L1M1T-1	Kilogram Meter Per Second	unit:KilogramMeterPerSecond	kg-m/s
            Sequence{ 1, 0, 0, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'm/K', 		L1Θ-1	Meter per kelvin	unit:MeterPerKelvin	m/K
            Sequence{ 1, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm/s', 		L1T-1	Meter per second	unit:MeterPerSecond	m/s
            Sequence{-2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},  -- 'cd/m^2', 		L-2J1	Candela per square meter	unit:CandelaPerSquareMeter	cd/m^2
            Sequence{ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1},  -- 'lm', 		U1J1	Lumen	unit:Lumen	lm
            Sequence{ 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'J/T', 		L2I1	Joule per Tesla	unit:JoulePerTesla	J/T
            Sequence{-1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'AT/m', 		L-1I1	Ampere Turn per Meter	unit:AmpereTurnPerMeter	At/m
            Sequence{ 2, 1,-2,-1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Wb', 		L2M1T-2I-1	Weber	unit:Weber	Wb
            Sequence{ 0, 1,-2,-1, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'T', 		M1T-2I-1	Tesla	unit:Tesla	T
            Sequence{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1},  -- 'AT', 		U1I1	Ampere Turn	unit:AmpereTurn	At
            Sequence{ 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},  -- 'kg*K', 		M1Θ1	Kilogram kelvin	unit:KilogramKelvin	kg-K
            Sequence{ 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'kg/s', 		M1T-1	Kilogram per second	unit:KilogramPerSecond	kg/s
            Sequence{-2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'kg/m^2', 		L-2M1	Kilogram per square meter	unit:KilogramPerSquareMeter	kg/m^2
            Sequence{-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'kg/m', 		L-1M1	Kilogram per meter	unit:KilogramPerMeter	kg/m
            Sequence{ 2, 1,-2, 0, 0,-1, 0, 0, 0, 0, 0, 0},  -- 'J/mol', 		L2M1T-2N-1	Joule per mole	unit:JoulePerMole	J/mol
            Sequence{ 2, 1,-2, 0,-1,-1, 0, 0, 0, 0, 0, 0},  -- 'J/(mol*K)', 		L2M1T-2Θ-1N-1	Joule per mole kelvin	unit:JoulePerMoleKelvin	J/(mol-K)
            Sequence{ 1, 1,-2,-2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'H/m', 		L1M1T-2I-2	Henry per meter	unit:HenryPerMeter	H/m
            Sequence{-3,-1, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'F/m', 		L-3M-1T4I2	Farad per meter	unit:FaradPerMeter	F/m
            Sequence{ 2, 1,-3, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'W', 		L2M1T-3	Watt	unit:Watt	W
            Sequence{ 2, 1,-3, 0, 0, 0, 0, 0, 0, 0, 0,-2},  -- 'W/sr', 		U-1L2M1T-3	Watt per steradian	unit:WattPerSteradian	W/sr
            Sequence{ 0, 1,-3, 0, 0, 0, 0, 0, 0, 0, 0,-2},  -- 'W/(m^2sr)', 		U-1M1T-3	Watt per square meter steradian	unit:WattPerSquareMeterSteradian	W/(m^2-sr)
            Sequence{ 0, 1,-3, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'W/m^2', 		M1T-3	Watt per square meter	unit:WattPerSquareMeter	W/m^2
            Sequence{-1, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Pa', 		L-1M1T-2	Pascal	unit:Pascal	Pa
            Sequence{ 2, 1,-3,-2, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'Ohm', 		L2M1T-3I-2	Ohm	unit:Ohm	Ohm
            Sequence{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2},  -- 'sr', 		U1	Steradian	unit:Steradian	sr
            Sequence{ 2, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'J/kg', 		L2T-2	Joule per kilogram	unit:JoulePerKilogram	J/kg
            Sequence{ 2, 0,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'J/(kg*K)', 		L2T-2Θ-1	Joule per kilogram kelvin	unit:JoulePerKilogramKelvin	J/(kg-K)
            Sequence{ 3,-1, 0, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'J/(kg*K*Pa)', 		L3M-1Θ-1	Joule per kilogram kelvin per pascal	unit:JoulePerKilogramKelvinPerPascal	J/(km-K-Pa)
            Sequence{-1, 0,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'J/(kg*K*m^3)', 		L-1T-2Θ-1	Joule per kilogram kelvin per cubic meter	unit:JoulePerKilogramKelvinPerCubicMeter	J/(kg-K-m^3)
            Sequence{ 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0},  -- 'mol*K', 		Θ1N1	Mole kelvin	unit:MoleKelvin	mol-K
            Sequence{ 1, 1,-3, 0,-1, 0, 0, 0, 0, 0, 0, 0},  -- 'W/(m*K)', 		L1M1T-3Θ-1	Watt per meter kelvin	unit:WattPerMeterKelvin	W/(m*K)
            Sequence{ 0,-1, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0},  -- 'm^2/W', 		M-1T3Θ1	Square meter Kelvin per watt	unit:SquareMeterKelvinPerWatt	(K^2)m/W
            Sequence{-2,-1, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0},  -- 'K/W', 		L-2M-1T3Θ1	Kelvin per watt	unit:KelvinPerWatt	K/W
            Sequence{-1,-1, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0},  -- 'm*K/W', 		L-1M-1T3Θ1	Meter Kelvin per watt	unit:MeterKelvinPerWatt	K-m/W
            Sequence{ 1, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'N/kg', 		L1T-2	Newton per kilogram	unit:NewtonPerKilogram	N/kg
            Sequence{ 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 's^2', 		T2	Second time squared	unit:SecondTimeSquared	s^2
            Sequence{ 2, 1,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'N*m', 		L2M1T-2	Newton meter	unit:NewtonMeter	N-m
            Sequence{ 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm^3', 		L3	Cubic Meter	unit:CubicMeter	m^3
            Sequence{ 3,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm^3/K', 		L3Θ-1	Cubic meter per kelvin	unit:CubicMeterPerKelvin	m^3/K
            Sequence{ 3, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  -- 'm^3/s', 		L3T-1	Cubic meter per second	unit:CubicMeterPerSecond	m^3/s
            Sequence{ 1, 1,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0}, -- 'J/(m^3*K)'		L-1M1T-2Θ-1	Joule per cubic meter kelvin	unit:JoulePerCubicMeterKelvin	J/(m^3 K)
            Sequence{ 0, 0,-1, 0, 0, 0, 0, 1, 0, 0, 0, 0} -- 'bit/s'		S1T-1 bit per second
            } in
	let DerivedUnitSymbols  : Sequence(String) =    Sequence{	
			'Gy',
			'Gy/s',
			'Bq',
			'mol/m^3',
			'mol/kg',
			'rad/s^2',
			'kg*m^2',
			'J*s',
			'rad/s',
			'm^2',
			'm^2*sr',
			'm^2*K',
			'm^2/K',
			'F',
			'kat',
			'W/(m^2*K)',
			'kg/m^3',
			'Sv',
			'Pa*s',
			'C',
			'C/m',
			'C/m^3',
			'C/mol',
			'A/m^2',
			'A/rad',
			'C*m',
			'V/m',
			'C/m^2',
			'S',
			'V',
			'J/m^3',
			'J',
			'J/m^2',
			'C/kg',
			'N',
			'N/C',
			'N/m',
			'Hz',
			'm^3/(kg*s^2)',
			'J/K',
			'lx',
			'H',
			'1/mol',
			'm/F',
			'm^2/s',
			'm*kg',
			'm*K',
			'm/s^2',
			'kg*m/s',
			'm/K',
			'm/s',
			'cd/m^2',
			'lm',
			'J/T',
			'AT/m',
			'Wb',
			'T',
			'AT',
			'kg*K',
			'kg/s',
			'kg/m^2',
			'kg/m',
			'J/mol',
			'J/(mol*K)',
			'H/m',
			'F/m',
			'W',
			'W/sr',
			'W/(m^2*sr)',
			'W/m^2',
			'Pa',
			'Ohm',
			'sr',
			'J/kg',
			'J/(kg*K)',
			'J/(kg*K*Pa)',
			'J/(kg*K*m^3)',
			'mol*K',
			'W/(m*K)',
			'K^2*m/W',
			'K/W',
			'm*K/W',
			'N/kg',
			's^2',
			'N*m',
			'm^3',
			'm^3/K',
			'm^3/s',
			'J/(m^3*K)',
            'bit/s' } in
if not self.symbol.oclIsUndefined() or self.isDimensionless() then self.symbol
else if self.isBaseUnit() then 
    BaseUnitSymbols->at(self.dimensions->indexOf(1.0))
else if self.isDerivedUnit() then
    DerivedUnitSymbols->at(DerivedUnitDimensions->indexOf(self.dimensions))
else Sequence{1..12}->iterate(i : Integer; acc : String = '' | if self.dimensions->at(i)<>0.0 then 
             acc.concat(BaseUnitSymbols->at(i)).concat('^').concat(self.dimensions->at(i).toString()) else acc endif)
endif endif endif

-- OPERATIONS ON QUANTITIES ---------------------------

multiplyUnits(x :Unit) :Unit  
-- dimensions are added because they are exponents
-- conversionFactors and offsets are not affected
    begin
        declare aux : Unit;
        aux := new Unit;
        aux.dimensions := self.dimensions->sum(x.dimensions);
        aux.conversionFactor := self.conversionFactor;
        aux.offset:= self.offset;
        aux.name:=aux.defaultName();
        aux.symbol:=aux.defaultSymbol();
        result := aux;
    end   
  
divideUnits(x:Unit) :Unit
-- dimensions are subtracted because they are exponents
-- conversionFactors and offsets are not affected
    begin
        declare aux : Unit;
        aux := new Unit;
        aux.dimensions := self.dimensions->minus(x.dimensions);
        aux.conversionFactor := self.conversionFactor;
        aux.offset:= self.offset;
        aux.name:=aux.defaultName();
        aux.symbol:=aux.defaultSymbol();
        result := aux;
    end   
  
powerUnits(s:Real) :Unit
    begin
        declare aux : Unit;
        aux := new Unit;
        aux.dimensions := self.dimensions->mult(s);
        aux.conversionFactor := self.conversionFactor;
        aux.offset:= self.offset;
        aux.name:=aux.defaultName();
        aux.symbol:=aux.defaultSymbol();
        result := aux;
    end   

-- auxiliary operations
noOffset() : Boolean = self.offset->count(0.0)=12

end -- of operations

constraints

context u : Unit inv twelveBaseDimensions:
    u.dimensions->size()=12

context u : Unit inv threeArraysSameLength:
    let n : Integer = u.dimensions->size in
        (u.offset->size = n) and (u.conversionFactor->size = n)
        
context u : Unit inv atMostOneOffset:
    u.offset->select(x | x<>0.0 )->size <= 1
    
-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

class Quantity

attributes
  value : UReal
  unit : Unit

operations

--- conversion operations

sameUnits(x :Quantity) :Boolean = self.unit.equals(x.unit)

compatibleUnits(u :Unit) :Boolean = self.unit.isCompatibleWith(u)

convertTo(u :Unit) :Quantity
   begin
      declare value1 : UReal, value2 : UReal, value3 : UReal, aux :Quantity;
      value1 := new UReal;
      value3 :=new UReal;
      value1.x := self.unit.factor()/u.factor();
      value1.u := 0.0;
      aux := new Quantity;
      value2:=self.value.mult(value1);
      value3.x := (self.unit.offset->sum() - u.offset->sum())/u.factor();
      value3.u:=0.0;
      aux.value:=value2.add(value3);
      aux.unit:= u;
      result := aux;
   end   

convertToSIUnits() :Quantity
  begin
    declare auxUnit : Unit;
    auxUnit:=new Unit;
    auxUnit.dimensions:=self.unit.dimensions;
    auxUnit.conversionFactor:=Sequence{1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0};
    auxUnit.offset:=Sequence{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
    auxUnit.name:=auxUnit.defaultName();
    auxUnit.symbol:=auxUnit.defaultSymbol();
    result:=self.convertTo(auxUnit);
  end   
--
  
convertFromSIUnits(val :UReal) :Quantity
    -- val is the Quantity value expressed in SIUnits
  begin
    declare auxQ : Quantity, auxUnit : Unit;
    auxUnit:=new Unit;
    auxUnit.dimensions:=self.unit.dimensions;
    auxUnit.conversionFactor:=Sequence{1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0};
    auxUnit.offset:=Sequence{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
    auxQ:=new Quantity;
    auxQ.value:=val;
    auxQ.unit:=auxUnit;
    result:=auxQ.convertTo(self.unit);
   end   

-- arithmetic operations -----------

add(x :Quantity) : Quantity
    begin
        declare one: Quantity, other : Quantity, auxR:UReal, auxR2:UReal;
        if self.unit.noOffset() then 
            other := x.convertTo(self.unit);
            one:=new Quantity;
            one.value := self.value.add(other.value);
            one.unit := self.unit;
            result := one;
        else -- self has offset, the other does not.
            one:= self.convertToSIUnits();
            other := x.convertToSIUnits();
            auxR:=one.value;
            auxR2:=auxR.add(other.value);
            result:=self.convertFromSIUnits(auxR2);
        end
    end   

minus(x :Quantity) : Quantity
    begin
        declare one: Quantity, other : Quantity, auxR:UReal, auxR2:UReal, auxU:Unit;
		if (x.unit.noOffset() and self.unit.noOffset()) then
			other := x.convertTo(self.unit);
            one:=new Quantity;
            one.value := self.value.minus(other.value);
            one.unit := self.unit;
            result := one;
		else 
            if x.unit.noOffset() then  -- x is a Delta Unit, but "self" is not
			   one := self.convertToSIUnits();
			   other := x.convertToSIUnits();
               auxR:=one.value;
               auxR2:=auxR.minus(other.value);
               result:=self.convertFromSIUnits(auxR2);
		    else -- neither x nor self are Delta Units, but the result should be a Delta Unit...
                 -- and then we convert to the  Delta"self" unit, with no offset
		       other:= x.convertTo(self.unit);
		       one:=new Quantity;
               auxR:=self.value;
               one.value:= auxR.minus(other.value);
               auxU:=new Unit;
               auxU.name:=self.unit.name.concat('delta'); -- we need to add the prefix "Delta"
               auxU.symbol:=self.unit.symbol.concat('delta'); -- we need to add the prefix "Delta"
               auxU.dimensions:=self.unit.dimensions;
               auxU.conversionFactor:=self.unit.conversionFactor;
               auxU.offset:=Sequence{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
               one.unit:=auxU;
               result:=one;		
            end
        end
    end   

mult(x :Quantity) : Quantity
    begin
        declare one: Quantity, other : Quantity, aux : Quantity;
        one:= self.convertToSIUnits();
        other := x.convertToSIUnits();
        aux := new Quantity;
        aux.value := one.value.mult(other.value);
        aux.unit := one.unit.multiplyUnits(other.unit);
        result := aux;
    end   

divideBy(x :Quantity) : Quantity
    begin
        declare one: Quantity, other : Quantity, aux : Quantity;
        one:= self.convertToSIUnits();
        other := x.convertToSIUnits();
        aux := new Quantity;
        aux.value := one.value.divideBy(other.value);
        aux.unit := one.unit.divideUnits(other.unit);
        result := aux;
    end   

abs() :Quantity
    begin
        declare aux : Quantity;
        aux := new Quantity;
        aux.value := self.value.abs();
        aux.unit := self.unit;
        result := aux;
    end   

neg() :Quantity
    begin
        declare aux : Quantity;
        aux := new Quantity;
        aux.value := self.value.neg();
        aux.unit := self.unit;
        result := aux;
    end   

power(s : Real) :Quantity
    begin
        declare aux : Quantity;
        aux := new Quantity;
        aux.value := self.value.power(s);
        aux.unit := self.unit.powerUnits(s);
        result := aux;
    end   

floor() :Quantity
    begin
        declare aux : Quantity;
        aux := new Quantity;
        aux.value := self.value.floor();
        aux.unit := self.unit;
        result := aux;
    end   

round() :Quantity
    begin
        declare aux : Quantity;
        aux := new Quantity;
        aux.value := self.value.round();
        aux.unit := self.unit;
        result := aux;
    end   

--- Multiplication by a scalar

-- sMult(x :Real) : Quantity
--     begin
--         declare aux : Quantity, ur : UReal;
--         aux := new Quantity;
--         ur := new UReal;
--         ur.x := x;
--         ur.u := 0.0;       
--         aux.value := self.value.mult(ur);
--         aux.unit := self.unit;
--         result := aux;
--     end   

sMult(x :UReal) : Quantity
    begin
        declare aux : Quantity, ur : UReal;
        aux := new Quantity;
        aux.value := self.value.mult(x);
        aux.unit := self.unit;
        result := aux;
    end   

--- COMPARISON OPERATIONS

equals(x :Quantity) :Boolean 
  begin
    declare other:Quantity;
    other:=x.convertTo(self.unit);
    result:=self.value.equals(other.value);
  end

distinct(x :Quantity) :Boolean -- = not self.equals(x)
  begin
    declare other:Quantity;
    other:=x.convertTo(self.unit);
    result:=not self.value.equals(other.value);
  end

lt(x :Quantity) :Boolean
  begin
    declare other:Quantity;
    other:=x.convertTo(self.unit);
    result:=self.value.lt(other.value);
  end

le(x :Quantity) :Boolean -- = self.lt(x) or self.equals(x)
  begin
    declare other:Quantity;
    other:=x.convertTo(self.unit);
    result:=self.value.le(other.value);
  end

gt(x :Quantity) :Boolean
  begin
    declare other:Quantity;
    other:=x.convertTo(self.unit);
    result:=self.value.gt(other.value);
  end

ge(x :Quantity) :Boolean -- = self.gt(x) or self.equals(x)
  begin
    declare other:Quantity;
    other:=x.convertTo(self.unit);
    result:=self.value.ge(other.value);
  end


max(x :Quantity) :Quantity -- = if x.lt(self) then self else x endif
  begin
    declare b:Boolean;
    b:=x.lt(self);
    if b then result:=self; 
    else result:=x;
    end
  end

min(x :Quantity) :Quantity -- = if self.lt(x) then self else x endif
  begin
    declare b:Boolean;
    b:=x.lt(self);
    if b then result:=x;
    else result:=self;
    end
  end

--- FUZZY COMPARISON OPERATIONS
--- Return a Real value with probablity between 0.0 a 1.0

uEquals(x :Quantity) :Real 
  begin
    declare other:Quantity;
    other:=x.convertTo(self.unit);
    result:=self.value.uEquals(other.value);
  end

uDistinct(x :Quantity) :Real -- = 1.0 - self.uEquals(x)
  begin
    declare other:Quantity;
    other:=x.convertTo(self.unit);
    result:=self.value.uDistinct(other.value);
  end

uLt(x :Quantity) :Real
  begin
    declare other:Quantity;
    other:=x.convertTo(self.unit);
    result:=self.value.uLt(other.value);
  end

uLe(x :Quantity) :Real 
  begin
    declare other:Quantity;
    other:=x.convertTo(self.unit);
    result:=self.value.uLe(other.value);
  end

uGt(x :Quantity) :Real
  begin
    declare other:Quantity;
    other:=x.convertTo(self.unit);
    result:=self.value.uGt(other.value);
  end

uGe(x :Quantity) :Real
  begin
    declare other:Quantity;
    other:=x.convertTo(self.unit);
    result:=self.value.uGe(other.value);
  end

end

constraints

context Quantity::add(x :Quantity) :Quantity
  pre: self.compatibleUnits(x.unit) 
       and x.unit.noOffset() -- operand should have no offset

context Quantity::minus(x :Quantity) :Quantity
  pre: self.compatibleUnits(x.unit)
       and (not x.unit.noOffset() implies not self.unit.noOffset())
       -- You can subtract two units with offset (although the 
       -- result will be a "delta" unit, i.e., with no offset 
       -- But if x has offset, self should have it too.

context Quantity::mult(x :Quantity) :Quantity
  pre: x.unit.noOffset() and self.unit.noOffset() -- both operands should have no offset

context Quantity::divideBy(x :Quantity) :Quantity
  pre: ((x.value.x - x.value.u).max(0) > (x.value.x + x.value.u).min(0)) --not x.value.equals(0,0)
       and x.unit.noOffset() and self.unit.noOffset() -- both operands should have no offset

context Quantity::power(s :Real) :Quantity
  pre: s<>0 implies self.unit.noOffset() 

context Quantity::equals(x :Quantity) :Boolean
  pre: self.compatibleUnits(x.unit)
       
context Quantity::distinct(x :Quantity) :Boolean
  pre: self.compatibleUnits(x.unit)
       
context Quantity::lt(x :Quantity) :Boolean
  pre: self.compatibleUnits(x.unit)
       
context Quantity::le(x :Quantity) :Boolean
  pre: self.compatibleUnits(x.unit)

context Quantity::gt(x :Quantity) :Boolean
  pre: self.compatibleUnits(x.unit)
       
context Quantity::ge(x :Quantity) :Boolean
  pre: self.compatibleUnits(x.unit)

context Quantity::uEquals(x :Quantity) :Real
  pre: self.compatibleUnits(x.unit)
       
context Quantity::uDistinct(x :Quantity) :Real
  pre: self.compatibleUnits(x.unit)
       
context Quantity::uLt(x :Quantity) :Real
  pre: self.compatibleUnits(x.unit)
       
context Quantity::uLe(x :Quantity) :Real
  pre: self.compatibleUnits(x.unit)

context Quantity::uGt(x :Quantity) :Real
  pre: self.compatibleUnits(x.unit)
       
context Quantity::uGe(x :Quantity) :Real
  pre: self.compatibleUnits(x.unit)

context Quantity::max(x :Quantity) :Quantity
  pre: self.compatibleUnits(x.unit)

context Quantity::min(x :Quantity) :Quantity
  pre: self.compatibleUnits(x.unit)
  
context Quantity::convertTo(u :Unit) :Quantity
  pre:  self.compatibleUnits(u)

-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

class Length

attributes
  value : UReal
  unit : Unit

operations

--- conversion operations

sameUnits(x :Quantity) :Boolean = self.unit.equals(x.unit)

compatibleUnits(u :Unit) :Boolean = self.unit.isCompatibleWith(u)

convertTo(u :Unit) :Length
   begin
      declare value1 : UReal, value2 : UReal, value3 : UReal, aux :Length;
      value1 := new UReal;
      value3 :=new UReal;
      value1.x := self.unit.factor()/u.factor();
      value1.u := 0.0;
      aux := new Length;
      value2:=self.value.mult(value1);
      value3.x := (self.unit.offset->sum() - u.offset->sum())/u.factor();
      value3.u:=0.0;
      aux.value:=value2.add(value3);
      aux.unit:= u;
      result := aux;
   end   

convertToSIUnits() :Length
  begin
    declare auxUnit : Unit;
    auxUnit:=new Unit;
    auxUnit.dimensions:=self.unit.dimensions;
    auxUnit.conversionFactor:=Sequence{1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0};
    auxUnit.offset:=Sequence{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
    auxUnit.name:=auxUnit.defaultName();
    auxUnit.symbol:=auxUnit.defaultSymbol();
    result:=self.convertTo(auxUnit);
  end   
--
  
convertFromSIUnits(val :UReal) :Length
    -- val is the Quantity value expressed in SIUnits
  begin
    declare auxQ : Length, auxUnit : Unit;
    auxUnit:=new Unit;
    auxUnit.dimensions:=self.unit.dimensions;
    auxUnit.conversionFactor:=Sequence{1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0};
    auxUnit.offset:=Sequence{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
    auxQ:=new Length;
    auxQ.value:=val;
    auxQ.unit:=auxUnit;
    result:=auxQ.convertTo(self.unit);
   end   

-- arithmetic operations -----------

add(x :Length) : Length
    begin
        declare one: Length, other : Length, auxR:UReal, auxR2:UReal;
        if self.unit.noOffset() then 
            other := x.convertTo(self.unit);
            one:=new Length;
            one.value := self.value.add(other.value);
            one.unit := self.unit;
            result := one;
        else -- self has offset, the other does not.
            one:= self.convertToSIUnits();
            other := x.convertToSIUnits();
            auxR:=one.value;
            auxR2:=auxR.add(other.value);
            result:=self.convertFromSIUnits(auxR2);
        end
    end   

minus(x :Length) : Length
    begin
        declare one: Length, other : Length, auxR:UReal, auxR2:UReal, auxU:Unit;
		if (x.unit.noOffset() and self.unit.noOffset()) then
			other := x.convertTo(self.unit);
            one:=new Length;
            one.value := self.value.minus(other.value);
            one.unit := self.unit;
            result := one;
		else 
            if x.unit.noOffset() then  -- x is a Delta Unit, but "self" is not
			   one := self.convertToSIUnits();
			   other := x.convertToSIUnits();
               auxR:=one.value;
               auxR2:=auxR.minus(other.value);
               result:=self.convertFromSIUnits(auxR2);
		    else -- neither x nor self are Delta Units, but the result should be a Delta Unit...
                 -- and then we convert to the  Delta"self" unit, with no offset
		       other:= x.convertTo(self.unit);
		       one:=new Length;
               auxR:=self.value;
               one.value:= auxR.minus(other.value);
               auxU:=new Unit;
               auxU.name:=self.unit.name.concat('delta'); -- we need to add the prefix "Delta"
               auxU.symbol:=self.unit.symbol.concat('delta'); -- we need to add the prefix "Delta"
               auxU.dimensions:=self.unit.dimensions;
               auxU.conversionFactor:=self.unit.conversionFactor;
               auxU.offset:=Sequence{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
               one.unit:=auxU;
               result:=one;		
            end
        end
    end   

-- mult(x :Length) : Length
--     begin
--         declare one: Length, other : Length, aux : Length;
--         one:= self.convertToSIUnits();
--         other := x.convertToSIUnits();
--         aux := new Length;
--         aux.value := one.value.mult(other.value);
--         aux.unit := one.unit.multiplyUnits(other.unit);
--         result := aux;
--     end   
-- 
-- divideBy(x :Length) : Length
--     begin
--         declare one: Length, other : Length, aux : Length;
--         one:= self.convertToSIUnits();
--         other := x.convertToSIUnits();
--         aux := new Length;
--         aux.value := one.value.divideBy(other.value);
--         aux.unit := one.unit.divideUnits(other.unit);
--         result := aux;
--     end   

abs() :Length
    begin
        declare aux : Length;
        aux := new Length;
        aux.value := self.value.abs();
        aux.unit := self.unit;
        result := aux;
    end   

neg() :Length
    begin
        declare aux : Length;
        aux := new Length;
        aux.value := self.value.neg();
        aux.unit := self.unit;
        result := aux;
    end   

-- power(s : Real) :Quantity
--     begin
--         declare aux : Length;
--         aux := new Length;
--         aux.value := self.value.power(s);
--         aux.unit := self.unit.powerUnits(s);
--         result := aux;
--     end   

floor() :Length
    begin
        declare aux : Length;
        aux := new Length;
        aux.value := self.value.floor();
        aux.unit := self.unit;
        result := aux;
    end   

round() :Length
    begin
        declare aux : Length;
        aux := new Length;
        aux.value := self.value.round();
        aux.unit := self.unit;
        result := aux;
    end   

--- Multiplication by a scalar

-- sMult(x :Real) : Length
--     begin
--         declare aux : Length, ur : UReal;
--         aux := new Length;
--         ur := new UReal;
--         ur.x := x;
--         ur.u := 0.0;       
--         aux.value := self.value.mult(ur);
--         aux.unit := self.unit;
--         result := aux;
--     end   

sMult(x :UReal) : Length
    begin
        declare aux : Length, ur : UReal;
        aux := new Length;
        aux.value := self.value.mult(x);
        aux.unit := self.unit;
        result := aux;
    end   

--- COMPARISON OPERATIONS

equals(x :Length) :Boolean 
  begin
    declare other:Length;
    other:=x.convertTo(self.unit);
    result:=self.value.equals(other.value);
  end

distinct(x :Length) :Boolean -- = not self.equals(x)
  begin
    declare other:Length;
    other:=x.convertTo(self.unit);
    result:=not self.value.equals(other.value);
  end

lt(x :Length) :Boolean
  begin
    declare other:Length;
    other:=x.convertTo(self.unit);
    result:=self.value.lt(other.value);
  end

le(x :Length) :Boolean -- = self.lt(x) or self.equals(x)
  begin
    declare other:Length;
    other:=x.convertTo(self.unit);
    result:=self.value.le(other.value);
  end

gt(x :Length) :Boolean
  begin
    declare other:Length;
    other:=x.convertTo(self.unit);
    result:=self.value.gt(other.value);
  end

ge(x :Length) :Boolean -- = self.gt(x) or self.equals(x)
  begin
    declare other:Length;
    other:=x.convertTo(self.unit);
    result:=self.value.ge(other.value);
  end


max(x :Length) :Length -- = if x.lt(self) then self else x endif
  begin
    declare b:Boolean;
    b:=x.lt(self);
    if b then result:=self; 
    else result:=x;
    end
  end

min(x :Length) :Length -- = if self.lt(x) then self else x endif
  begin
    declare b:Boolean;
    b:=x.lt(self);
    if b then result:=x;
    else result:=self;
    end
  end

--- FUZZY COMPARISON OPERATIONS
--- Return a Real value with probablity between 0.0 a 1.0

uEquals(x :Length) :Real 
  begin
    declare other:Length;
    other:=x.convertTo(self.unit);
    result:=self.value.uEquals(other.value);
  end

uDistinct(x :Length) :Real -- = 1.0 - self.uEquals(x)
  begin
    declare other:Length;
    other:=x.convertTo(self.unit);
    result:=self.value.uDistinct(other.value);
  end

uLt(x :Length) :Real
  begin
    declare other:Length;
    other:=x.convertTo(self.unit);
    result:=self.value.uLt(other.value);
  end

uLe(x :Length) :Real 
  begin
    declare other:Length;
    other:=x.convertTo(self.unit);
    result:=self.value.uLe(other.value);
  end

uGt(x :Length) :Real
  begin
    declare other:Length;
    other:=x.convertTo(self.unit);
    result:=self.value.uGt(other.value);
  end

uGe(x :Length) :Real
  begin
    declare other:Length;
    other:=x.convertTo(self.unit);
    result:=self.value.uGe(other.value);
  end

end

constraints

context Length inv correctLengthUnits:
  self.unit.dimensions=Sequence{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

context Length::add(x :Length) :Length
  pre: self.compatibleUnits(x.unit) 
       and x.unit.noOffset() -- operand should have no offset

context Length::minus(x :Length) :Length
  pre: self.compatibleUnits(x.unit)
       and (not x.unit.noOffset() implies not self.unit.noOffset())
       -- You can subtract two units with offset (although the 
       -- result will be a "delta" unit, i.e., with no offset 
       -- But if x has offset, self should have it too.

-- context Length::mult(x :Length) :Length
--   pre: x.unit.noOffset() and self.unit.noOffset() -- both operands should have no offset
-- 
-- context Length::divideBy(x :Length) :Length
--   pre: ((x.value.x - x.value.u).max(0) > (x.value.x + x.value.u).min(0)) --not x.value.equals(0,0)
--        and x.unit.noOffset() and self.unit.noOffset() -- both operands should have no offset
--
-- context Length::power(s :Real) :Length
--   pre: s<>0 implies self.unit.noOffset() 

context Length::equals(x :Length) :Boolean
  pre: self.compatibleUnits(x.unit)
       
context Length::distinct(x :Length) :Boolean
  pre: self.compatibleUnits(x.unit)
       
context Length::lt(x :Length) :Boolean
  pre: self.compatibleUnits(x.unit)
       
context Length::le(x :Length) :Boolean
  pre: self.compatibleUnits(x.unit)

context Length::gt(x :Length) :Boolean
  pre: self.compatibleUnits(x.unit)
       
context Length::ge(x :Length) :Boolean
  pre: self.compatibleUnits(x.unit)

context Length::uEquals(x :Length) :Real
  pre: self.compatibleUnits(x.unit)
       
context Length::uDistinct(x :Length) :Real
  pre: self.compatibleUnits(x.unit)
       
context Length::uLt(x :Length) :Real
  pre: self.compatibleUnits(x.unit)
       
context Length::uLe(x :Length) :Real
  pre: self.compatibleUnits(x.unit)

context Length::uGt(x :Length) :Real
  pre: self.compatibleUnits(x.unit)
       
context Length::uGe(x :Length) :Real
  pre: self.compatibleUnits(x.unit)

context Length::max(x :Length) :Length
  pre: self.compatibleUnits(x.unit)

context Length::min(x :Length) :Length
  pre: self.compatibleUnits(x.unit)
  
context Length::convertTo(u :Unit) :Length
  pre:  self.compatibleUnits(u)
  
  -- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

class Angle

attributes
  value : UReal
  unit : Unit

operations

--- conversion operations

sameUnits(x :Quantity) :Boolean = self.unit.equals(x.unit)

compatibleUnits(u :Unit) :Boolean = self.unit.isCompatibleWith(u)

convertTo(u :Unit) :Angle
   begin
      declare value1 : UReal, value2 : UReal, value3 : UReal, aux :Angle;
      value1 := new UReal;
      value3 :=new UReal;
      value1.x := self.unit.factor()/u.factor();
      value1.u := 0.0;
      aux := new Angle;
      value2:=self.value.mult(value1);
      value3.x := (self.unit.offset->sum() - u.offset->sum())/u.factor();
      value3.u:=0.0;
      aux.value:=value2.add(value3);
      aux.unit:= u;
      result := aux;
   end

convertToSIUnits() :Angle
  begin
    declare auxUnit : Unit;
    auxUnit:=new Unit;
    auxUnit.dimensions:=self.unit.dimensions;
    auxUnit.conversionFactor:=Sequence{1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0};
    auxUnit.offset:=Sequence{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
    auxUnit.name:=auxUnit.defaultName();
    auxUnit.symbol:=auxUnit.defaultSymbol();
    result:=self.convertTo(auxUnit);
  end
--

convertFromSIUnits(val :UReal) :Angle
    -- val is the Quantity value expressed in SIUnits
  begin
    declare auxQ : Angle, auxUnit : Unit;
    auxUnit:=new Unit;
    auxUnit.dimensions:=self.unit.dimensions;
    auxUnit.conversionFactor:=Sequence{1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0};
    auxUnit.offset:=Sequence{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
    auxQ:=new Angle;
    auxQ.value:=val;
    auxQ.unit:=auxUnit;
    result:=auxQ.convertTo(self.unit);
   end

-- arithmetic operations -----------

add(x :Angle) : Angle
    begin
        declare one: Angle, other : Angle, auxR:UReal, auxR2:UReal;
        if self.unit.noOffset() then
            other := x.convertTo(self.unit);
            one:=new Angle;
            one.value := self.value.add(other.value);
            one.unit := self.unit;
            result := one;
        else -- self has offset, the other does not.
            one:= self.convertToSIUnits();
            other := x.convertToSIUnits();
            auxR:=one.value;
            auxR2:=auxR.add(other.value);
            result:=self.convertFromSIUnits(auxR2);
        end
    end

minus(x :Angle) : Angle
    begin
        declare one: Angle, other : Angle, auxR:UReal, auxR2:UReal, auxU:Unit;
		if (x.unit.noOffset() and self.unit.noOffset()) then
			other := x.convertTo(self.unit);
            one:=new Angle;
            one.value := self.value.minus(other.value);
            one.unit := self.unit;
            result := one;
		else
            if x.unit.noOffset() then  -- x is a Delta Unit, but "self" is not
			   one := self.convertToSIUnits();
			   other := x.convertToSIUnits();
               auxR:=one.value;
               auxR2:=auxR.minus(other.value);
               result:=self.convertFromSIUnits(auxR2);
		    else -- neither x nor self are Delta Units, but the result should be a Delta Unit...
                 -- and then we convert to the  Delta"self" unit, with no offset
		       other:= x.convertTo(self.unit);
		       one:=new Angle;
               auxR:=self.value;
               one.value:= auxR.minus(other.value);
               auxU:=new Unit;
               auxU.name:=self.unit.name.concat('delta'); -- we need to add the prefix "Delta"
               auxU.symbol:=self.unit.symbol.concat('delta'); -- we need to add the prefix "Delta"
               auxU.dimensions:=self.unit.dimensions;
               auxU.conversionFactor:=self.unit.conversionFactor;
               auxU.offset:=Sequence{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
               one.unit:=auxU;
               result:=one;		
            end
        end
    end

sin() :UReal
    begin
        result := self.value.sin();
    end
cos() :UReal
    begin
        result := self.value.cos();
    end


-- mult(x :Angle) : Angle
--     begin
--         declare one: Angle, other : Angle, aux : Angle;
--         one:= self.convertToSIUnits();
--         other := x.convertToSIUnits();
--         aux := new Angle;
--         aux.value := one.value.mult(other.value);
--         aux.unit := one.unit.multiplyUnits(other.unit);
--         result := aux;
--     end
--
-- divideBy(x :Angle) : Angle
--     begin
--         declare one: Angle, other : Angle, aux : Angle;
--         one:= self.convertToSIUnits();
--         other := x.convertToSIUnits();
--         aux := new Angle;
--         aux.value := one.value.divideBy(other.value);
--         aux.unit := one.unit.divideUnits(other.unit);
--         result := aux;
--     end

abs() :Angle
    begin
        declare aux : Angle;
        aux := new Angle;
        aux.value := self.value.abs();
        aux.unit := self.unit;
        result := aux;
    end

neg() :Angle
    begin
        declare aux : Angle;
        aux := new Angle;
        aux.value := self.value.neg();
        aux.unit := self.unit;
        result := aux;
    end

-- power(s : Real) :Quantity
--     begin
--         declare aux : Angle;
--         aux := new Angle;
--         aux.value := self.value.power(s);
--         aux.unit := self.unit.powerUnits(s);
--         result := aux;
--     end

floor() :Angle
    begin
        declare aux : Angle;
        aux := new Angle;
        aux.value := self.value.floor();
        aux.unit := self.unit;
        result := aux;
    end

round() :Angle
    begin
        declare aux : Angle;
        aux := new Angle;
        aux.value := self.value.round();
        aux.unit := self.unit;
        result := aux;
    end

--- Multiplication by a scalar

-- sMult(x :Real) : Angle
--     begin
--         declare aux : Angle, ur : UReal;
--         aux := new Angle;
--         ur := new UReal;
--         ur.x := x;
--         ur.u := 0.0;
--         aux.value := self.value.mult(ur);
--         aux.unit := self.unit;
--         result := aux;
--     end

sMult(x :UReal) : Angle
    begin
        declare aux : Angle, ur : UReal;
        aux := new Angle;
        aux.value := self.value.mult(x);
        aux.unit := self.unit;
        result := aux;
    end

--- COMPARISON OPERATIONS

equals(x :Angle) :Boolean
  begin
    declare other:Angle;
    other:=x.convertTo(self.unit);
    result:=self.value.equals(other.value);
  end

distinct(x :Angle) :Boolean -- = not self.equals(x)
  begin
    declare other:Angle;
    other:=x.convertTo(self.unit);
    result:=not self.value.equals(other.value);
  end

lt(x :Angle) :Boolean
  begin
    declare other:Angle;
    other:=x.convertTo(self.unit);
    result:=self.value.lt(other.value);
  end

le(x :Angle) :Boolean -- = self.lt(x) or self.equals(x)
  begin
    declare other:Angle;
    other:=x.convertTo(self.unit);
    result:=self.value.le(other.value);
  end

gt(x :Angle) :Boolean
  begin
    declare other:Angle;
    other:=x.convertTo(self.unit);
    result:=self.value.gt(other.value);
  end

ge(x :Angle) :Boolean -- = self.gt(x) or self.equals(x)
  begin
    declare other:Angle;
    other:=x.convertTo(self.unit);
    result:=self.value.ge(other.value);
  end


max(x :Angle) :Angle -- = if x.lt(self) then self else x endif
  begin
    declare b:Boolean;
    b:=x.lt(self);
    if b then result:=self;
    else result:=x;
    end
  end

min(x :Angle) :Angle -- = if self.lt(x) then self else x endif
  begin
    declare b:Boolean;
    b:=x.lt(self);
    if b then result:=x;
    else result:=self;
    end
  end

--- FUZZY COMPARISON OPERATIONS
--- Return a Real value with probablity between 0.0 a 1.0

uEquals(x :Angle) :Real
  begin
    declare other:Angle;
    other:=x.convertTo(self.unit);
    result:=self.value.uEquals(other.value);
  end

uDistinct(x :Angle) :Real -- = 1.0 - self.uEquals(x)
  begin
    declare other:Angle;
    other:=x.convertTo(self.unit);
    result:=self.value.uDistinct(other.value);
  end

uLt(x :Angle) :Real
  begin
    declare other:Angle;
    other:=x.convertTo(self.unit);
    result:=self.value.uLt(other.value);
  end

uLe(x :Angle) :Real
  begin
    declare other:Angle;
    other:=x.convertTo(self.unit);
    result:=self.value.uLe(other.value);
  end

uGt(x :Angle) :Real
  begin
    declare other:Angle;
    other:=x.convertTo(self.unit);
    result:=self.value.uGt(other.value);
  end

uGe(x :Angle) :Real
  begin
    declare other:Angle;
    other:=x.convertTo(self.unit);
    result:=self.value.uGe(other.value);
  end

end

constraints

context Angle inv correctAngleUnits:
  self.unit.dimensions=Sequence{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}

context Angle::add(x :Angle) :Angle
  pre: self.compatibleUnits(x.unit)
       and x.unit.noOffset() -- operand should have no offset

context Angle::minus(x :Angle) :Angle
  pre: self.compatibleUnits(x.unit)
       and (not x.unit.noOffset() implies not self.unit.noOffset())
       -- You can subtract two units with offset (although the
       -- result will be a "delta" unit, i.e., with no offset
       -- But if x has offset, self should have it too.

context Angle::equals(x :Angle) :Boolean
  pre: self.compatibleUnits(x.unit)

context Angle::distinct(x :Angle) :Boolean
  pre: self.compatibleUnits(x.unit)

context Angle::lt(x :Angle) :Boolean
  pre: self.compatibleUnits(x.unit)

context Angle::le(x :Angle) :Boolean
  pre: self.compatibleUnits(x.unit)

context Angle::gt(x :Angle) :Boolean
  pre: self.compatibleUnits(x.unit)

context Angle::ge(x :Angle) :Boolean
  pre: self.compatibleUnits(x.unit)

context Angle::uEquals(x :Angle) :Real
  pre: self.compatibleUnits(x.unit)

context Angle::uDistinct(x :Angle) :Real
  pre: self.compatibleUnits(x.unit)

context Angle::uLt(x :Angle) :Real
  pre: self.compatibleUnits(x.unit)

context Angle::uLe(x :Angle) :Real
  pre: self.compatibleUnits(x.unit)

context Angle::uGt(x :Angle) :Real
  pre: self.compatibleUnits(x.unit)

context Angle::uGe(x :Angle) :Real
  pre: self.compatibleUnits(x.unit)

context Angle::max(x :Angle) :Angle
  pre: self.compatibleUnits(x.unit)

context Angle::min(x :Angle) :Angle
  pre: self.compatibleUnits(x.unit)

context Angle::convertTo(u :Unit) :Angle
  pre:  self.compatibleUnits(u)


-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- 
class UReal

attributes
    x : Real
    u : Real

operations

add(r : UReal) : UReal
    begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x + r.x;
        aux.u := (self.u*self.u + r.u*r.u).sqrt();
        result := aux;
    end   

minus(r : UReal) : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x - r.x;
        aux.u := (self.u*self.u + r.u*r.u).sqrt();
        result := aux;
    end   
   
mult(r : UReal) : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x*r.x;
        aux.u := (r.u*r.u*self.x*self.x + self.u*self.u*r.x*r.x).sqrt();
        result := aux;
     end   
    
divideBy(r : UReal) : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := (self.x/r.x + (self.x*r.u*r.u)/(r.x*r.x*r.x));
        aux.u := ((self.u*self.u/r.x) + 
                 ((r.u*r.u*self.x*self.x)/(r.x*r.x*r.x*r.x))).sqrt();
        result := aux;
    end   

sin() :UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x.sin();
        aux.u := self.x.cos() * self.u ;
        result := aux;
    end   

cos() :UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x.cos();
        aux.u := self.x.sin() * self.u ;
        result := aux;
    end   
   
abs() : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := (self.x).abs();
        aux.u := self.u;
        result := aux;
    end   
    
neg() : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := -self.x;
        aux.u := self.u;
        result := aux;
    end   

floor() : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x.floor();
        aux.u := self.u;
        result := aux;
    end   
    
round() : UReal
    begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x.round();
        aux.u := self.u;
        result := aux;
    end   
    
    
inverse() : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := 1.0;
        aux.u := 0.0;
        result := aux.divideBy(self);
    end   
    
power (s : Real) : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x.power(s) + ((s*(s-1))/2)*self.x.power(s-2)*(self.u*self.u);
        aux.u := s*self.u*self.x.power(s-1);
        result := aux;
    end   
    
sqrt() : UReal 
    begin
        declare aux : UReal;
        aux := self.power(0.5);
        result := aux;
    end
   
-- comparison operations

equals(r : UReal) : Boolean 
   = (self.x - self.u).max(r.x - r.u) <= 
         (self.x + self.u).min(r.x + r.u)
   
distinct(r : UReal) : Boolean
    = not self.equals(r) 

compareTo(r : UReal) : Integer
    = if self.equals(r) then 0
      else if self.lt(r) then -1 
           else 1 
           endif 
      endif

lt(r : UReal) : Boolean
   = (self.x<r.x) and ((self.x + self.u)<(r.x - r.u)) 

le(r : UReal) : Boolean 
   = self.lt(r) or self.equals(r)
    
gt(r : UReal) : Boolean
   = not self.le(r) 

ge(r : UReal) : Boolean 
   = not self.lt(r)

max(r : UReal) : UReal
    = if r.lt(self) then self else r endif
   
min(r : UReal) : UReal
    = if r.lt(self) then r else self endif

   
-- Fuzzy comparison operations

-- aux operation
calculate(r : UReal) :Tuple(lt:Real,eq:Real,gt:Real)
begin
            declare m1 : Real, m2 : Real, s1 : Real, s2 : Real, crossing1 : Real, crossing2 : Real, 
                    r1 : Real, r2 : Real, c1 : Real, c2 : Real,
                    aux : Tuple(lt:Real,eq:Real,gt:Real), swap : Boolean;
            if (self.x <= r.x) then
                m1:=self.x; m2:=r.x; s1:=self.u; s2:=r.u; swap:=false;
            else
                m2:=self.x; m1:=r.x; s2:=self.u; s1:=r.u; swap:=true;
            end;
            if (s1=0.0) and (s2=0.0) then  -- Real numbers
                if (m1=m2) then 
                    aux:=Tuple{lt:0.0,eq:1.0,gt:0.0};
                else
                    if (m1<m2) then
                        aux:=Tuple{lt:1.0,eq:0.0,gt:0.0};
                    else
                        aux:=Tuple{lt:0.0,eq:0.0,gt:1.0};
                    end
                end
            else 
           		if ((s1=0.0)) then --- s1 is degenerated, s2 is not
                   aux:=Tuple{lt:1.0-m1.cdf(m2,s2),eq:0.0,gt:m1.cdf(m2,s2)};
                else
                    if ((s2=0.0))  then  --- s2 is degenerated, s1 is not
                        aux:=Tuple{lt:m2.cdf(m1,s1),eq:0.0,gt:1.0-m2.cdf(m1,s1)};
                    else --- none of the two numbers are degenerated. This is where the fun starts...
                        if (s1=s2) then
                            crossing1 := (m1+m2)/2;
                            aux:=Tuple{
                        		 lt:crossing1.cdf(m1,s1)-crossing1.cdf(m2,s2),
			                     eq:crossing1.cdf(m2,s2)+1.0-crossing1.cdf(m1,s1),
			                     gt:1.0-crossing1.cdf(m2,s2)-(1.0-crossing1.cdf(m1,s1))
                            };
                        else
                            r1:=(s2/s1).log();
                            r2:=((m1-m2)*(m1-m2)-2.0*(s1*s1-s2*s2)*r1).sqrt();
                            crossing1:= -(-m2*s1*s1 + m1*s2*s2 + s1*s2*r2 )/(s1*s1 - s2*s2);	
                            crossing2:=  ( m2*s1*s1 - m1*s2*s2 + s1*s2*r2 )/(s1*s1 - s2*s2);
                            c1:=crossing1.min(crossing2);
                            c2:=crossing1.max(crossing2);
                            if (s1<s2) then
                                aux:=Tuple{
                                    lt:1.0-c2.cdf(m2,s2)-(1.0-c2.cdf(m1,s1)),
                                    eq:c1.cdf(m1,s1) + (1.0-c2.cdf(m1,s1)) + c2.cdf(m2,s2) - c1.cdf(m2,s2),
                                    gt:c1.cdf(m2,s2)-c1.cdf(m1,s1)
                                };
                            else
                                aux:=Tuple{
                                    lt:c1.cdf(m1,s1)-c1.cdf(m2,s2),
                                    eq:c1.cdf(m2,s2) + (1.0-c2.cdf(m2,s2)) + c2.cdf(m1,s1) - c1.cdf(m1,s1),
                                    gt:1.0-c2.cdf(m1,s1)-(1.0-c2.cdf(m2,s2))
                                };
                            end
                        end --- end of fun
                    end
                end            
            end;
            if (swap) then 
                result:=Tuple{lt:aux.gt,eq:aux.eq,gt:aux.lt};
            else
                result:=Tuple{lt:aux.lt,eq:aux.eq,gt:aux.gt};
            end
end -- calculate

-- fuzzy operations

uEquals(r : UReal) : Real
    begin
       declare aux : Tuple(lt:Real,eq:Real,gt:Real);		
       aux:=self.calculate(r);
       result := aux.eq;
    end

uDistinct(r : UReal) : Real
    begin
        declare aux : Real;
        aux := self.uEquals(r);
        result := 1.0 - aux;
    end

uLt(r : UReal) : Real
     begin
       declare aux : Tuple(lt:Real,eq:Real,gt:Real);		
       aux:=self.calculate(r);
       result := aux.lt;
    end

uLe(r : UReal) : Real 
     begin
       declare aux : Tuple(lt:Real,eq:Real,gt:Real);		
       aux:=self.calculate(r);
       result := aux.lt+aux.eq;
    end
   
uGt(r : UReal) : Real
     begin
       declare aux : Tuple(lt:Real,eq:Real,gt:Real);		
       aux:=self.calculate(r);
       result := aux.gt;
    end

uGe(r : UReal) : Real 
     begin
       declare aux : Tuple(lt:Real,eq:Real,gt:Real);		
       aux:=self.calculate(r);
       result := aux.gt+aux.eq;
    end
 
end

constraints -- precondition on operations

context UReal::divideBy(r : UReal) : UReal
pre: (r.x - r.u).max(0) > (r.x + r.u).min(0) --not r.equals(0,0)

context UReal::sqrt() : UReal
pre:  (self.x + self.u)>=0.0 

context UReal::inverse() : UReal
    pre:  (self.x - self.u).max(0) > (self.x + self.u).min(0) -- not self.equals(0.0)
